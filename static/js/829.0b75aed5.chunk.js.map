{"version":3,"file":"static/js/829.0b75aed5.chunk.js","mappings":"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","sources":["utils/dates.js","utils/analysis.js","workers/multiCarWorker.js"],"sourcesContent":["// Canonical date utilities\r\n// PRESERVED EXACT COMPLIANCE with original src/utils.js\r\n\r\nexport const parseRevenueDate = (dateStr) => {\r\n    // Check if it's already a Date object from cellDates:true\r\n    if (dateStr instanceof Date) {\r\n        return dateStr;\r\n    }\r\n    if (typeof dateStr !== 'string' || !dateStr) {\r\n        return null;\r\n    }\r\n    // Handle ISO format with 'T' and 'Z'\r\n    if (dateStr.includes('T') && dateStr.includes('Z')) {\r\n        return new Date(dateStr);\r\n    }\r\n    // Handle 'YYYY-MM-DD HH:mm:ss' format\r\n    const parts = dateStr.split(' ')[0].split('-');\r\n    if (parts.length === 3) {\r\n        const [year, month, day] = parts.map(p => parseInt(p, 10));\r\n        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {\r\n            // Month is 0-indexed in JavaScript Date\r\n            return new Date(Date.UTC(year, month - 1, day));\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nexport const formatDateDDMMYYYY = (date) => {\r\n    if (!(date instanceof Date) || isNaN(date)) {\r\n        return 'Invalid Date';\r\n    }\r\n    // Use UTC dates to avoid timezone issues from the UTC date object\r\n    const day = String(date.getUTCDate()).padStart(2, '0');\r\n    const month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Month is 0-indexed\r\n    const year = date.getUTCFullYear();\r\n    return `${day}/${month}/${year}`;\r\n};\r\n\r\nexport const formatDateForDisplay = (dateStr) => {\r\n    if (!dateStr || dateStr.trim() === '') return '';\r\n\r\n    // Handle different date formats and remove time\r\n    let cleanDate = dateStr.toString();\r\n\r\n    // Remove time part if it exists (format: DD-MM-YYYYHHMM or DD/MM/YYYYHHMM)\r\n    const dateTimeMatch = cleanDate.match(/^(\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{4})(\\d{4})?/);\r\n    if (dateTimeMatch) {\r\n        cleanDate = dateTimeMatch[1]; // Get only the date part\r\n    } else {\r\n        // Handle space-separated date and time\r\n        cleanDate = cleanDate.split(' ')[0];\r\n    }\r\n\r\n    // Convert all dates to DD/MM/YYYY format\r\n    if (cleanDate.includes('-')) {\r\n        return cleanDate.replace(/-/g, '/');\r\n    }\r\n\r\n    return cleanDate;\r\n};\r\n\r\nexport const parseSheetDate = (dateStr) => {\r\n    if (!dateStr || dateStr.trim() === '') return null;\r\n    const normalizedStr = dateStr.replace(/\\//g, '-');\r\n    const parts = normalizedStr.split('-');\r\n    if (parts.length !== 3) {\r\n        const d = new Date(dateStr);\r\n        return isNaN(d.getTime()) ? null : d;\r\n    }\r\n    let [day, month, year] = parts.map(p => parseInt(p, 10));\r\n    if (isNaN(day) || isNaN(month) || isNaN(year)) {\r\n        const d = new Date(dateStr);\r\n        return isNaN(d.getTime()) ? null : d;\r\n    }\r\n    if (year < 100) year += 2000;\r\n    const d = new Date(Date.UTC(year, month - 1, day));\r\n    return isNaN(d.getTime()) ? null : d;\r\n};\r\n","import { normalize, normalizePhoneNumber } from './normalize';\r\nimport { parseRevenueDate, formatDateDDMMYYYY, parseSheetDate } from './dates';\r\n\r\n// Canonical analysis utilities\r\n// PRESERVED EXACT COMPLIANCE with original src/utils.js\r\n\r\n// Function to analyze multi-car contracts\r\n// This function groups contracts by Contract No. and finds contracts with multiple different cars\r\nexport const analyzeMultiCarContracts = (data) => {\r\n    // تجميع العقود حسب رقم العقد وتجميع السيارات داخل كل عقد\r\n    const contractGroups = {};\r\n    const debugCounts = {};\r\n    // دالة تطبيع رقم اللوحة\r\n    const normalizePlate = (str) => (str || '').toString().replace(/\\s+/g, '').toUpperCase();\r\n    data.forEach(row => {\r\n        const contractNo = row['Contract No.'];\r\n        const plateNumberRaw = row['Plate Number'];\r\n        const plateNumber = normalizePlate(plateNumberRaw);\r\n\r\n        // Try multiple variations for Customer and Model\r\n        const customerName = row['Customer Name'] || row['Customer'] || row['customer'] || row['Name'] || '';\r\n        const carModel = row['Car Model'] || row['Model'] || row['model'] || row['Vehicle'] || '';\r\n\r\n        const revenueDateValue = row['Revenue Date'];\r\n        const revenueDate = parseSheetDate(revenueDateValue);\r\n\r\n        if (!contractNo || !plateNumber || !revenueDate) {\r\n            return;\r\n        }\r\n        if (!contractGroups[contractNo]) {\r\n            contractGroups[contractNo] = {\r\n                contractNo,\r\n                customerName,\r\n                cars: {},\r\n                carsRaw: {},\r\n            };\r\n        }\r\n        if (!contractGroups[contractNo].cars[plateNumber]) {\r\n            contractGroups[contractNo].cars[plateNumber] = {\r\n                plateNumber,\r\n                carModel,\r\n                dates: [],\r\n            };\r\n            contractGroups[contractNo].carsRaw[plateNumber] = plateNumberRaw;\r\n        }\r\n        contractGroups[contractNo].cars[plateNumber].dates.push(revenueDate);\r\n    });\r\n\r\n    // تجهيز النتائج النهائية\r\n    const results = [];\r\n    Object.values(contractGroups).forEach(contract => {\r\n        debugCounts[contract.contractNo] = Object.keys(contract.cars).length + ' => [' + Object.values(contract.carsRaw).join(', ') + ']';\r\n        const carEntries = Object.values(contract.cars);\r\n        if (carEntries.length <= 1) return; // استبعاد العقود التي بها سيارة واحدة فقط\r\n        const carDetails = carEntries.map(car => {\r\n            // حساب أول وآخر تاريخ\r\n            const sortedDates = car.dates.sort((a, b) => a - b);\r\n            return {\r\n                plateNumber: car.plateNumber,\r\n                carModel: car.carModel,\r\n                from: formatDateDDMMYYYY(sortedDates[0]),\r\n                to: formatDateDDMMYYYY(sortedDates[sortedDates.length - 1])\r\n            };\r\n        });\r\n        results.push({\r\n            contractNo: contract.contractNo,\r\n            customerName: contract.customerName,\r\n            carsCount: carEntries.length,\r\n            carDetails\r\n        });\r\n        // Debug: عرض العقود وعدد السيارات\r\n        // alert('عقود وعدد السيارات:\\n' + Object.entries(debugCounts).map(([c, n]) => c + ': ' + n).join('\\n'));\r\n    });\r\n    return results;\r\n};\r\n\r\nexport const getLatestDateIn = (row, maintenanceData) => {\r\n    if (!row || !maintenanceData || !row.invygoPlate) return null;\r\n    const vehicleRecords = maintenanceData.filter(m => normalize(m[\"Vehicle\"]) === normalize(row.invygoPlate));\r\n    if (vehicleRecords.length === 0) return null;\r\n    const datesIn = vehicleRecords.map(r => parseSheetDate(r[\"Date IN\"])).filter(Boolean);\r\n    const datesOut = vehicleRecords.map(r => parseSheetDate(r[\"Date OUT\"])).filter(Boolean);\r\n    if (datesIn.length === 0) return null;\r\n    const latestDateIn = new Date(Math.max(...datesIn.map(d => d.getTime())));\r\n    const latestDateOut = datesOut.length > 0 ? new Date(Math.max(...datesOut.map(d => d.getTime()))) : null;\r\n    if (latestDateOut && latestDateOut.getTime() > latestDateIn.getTime()) return null;\r\n    return latestDateIn;\r\n};\r\n\r\nexport const isMismatch = (row) => {\r\n    const isNumeric = !isNaN(Number(row.bookingNumber));\r\n    const ejar = normalize(row.ejarPlate);\r\n    const invygo = normalize(row.invygoPlate);\r\n    return isNumeric && ejar && invygo && ejar !== invygo;\r\n};\r\n\r\nexport const getDaysSinceLatestIn = (row, maintenanceData) => {\r\n    const latestDate = getLatestDateIn(row, maintenanceData);\r\n    if (!latestDate) return '';\r\n    const today = new Date();\r\n    const diffTime = today.getTime() - latestDate.getTime();\r\n    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\r\n    return diffDays >= 0 ? diffDays : '';\r\n};\r\n","/* eslint-disable no-restricted-globals */\r\nimport { analyzeMultiCarContracts } from '../utils/analysis';\r\n\r\n// Global state for determining if we are accumulating\r\nlet accumulatedRows = [];\r\n\r\nself.onmessage = (event) => {\r\n    const { type, data } = event.data;\r\n\r\n    try {\r\n        if (type === 'CHUNK') {\r\n            // Append rows\r\n            // data is array of objects (if header:true used in PapaParse)\r\n            if (Array.isArray(data)) {\r\n                // Use concat loop or simple push loop to avoid stack overflow with spread\r\n                for (let i = 0; i < data.length; i++) {\r\n                    accumulatedRows.push(data[i]);\r\n                }\r\n            }\r\n            // Report progress if needed (optional)\r\n            self.postMessage({\r\n                progress: `Processed ${accumulatedRows.length} rows...`\r\n            });\r\n        }\r\n        else if (type === 'DONE') {\r\n            self.postMessage({ progress: 'Analyzing contracts...' });\r\n\r\n            // Perform analysis\r\n            const results = analyzeMultiCarContracts(accumulatedRows);\r\n\r\n            // Calculate summary\r\n            const singleCarContracts = accumulatedRows.length; // Approximate/Proxy metric or calculate real one?\r\n            // Wait, original logic calculated singleCarContracts count inside the analysis or adjacent?\r\n            // Original code in MultiContractPage.js:\r\n            /*\r\n            const summary = {\r\n                totalRows: jsonData.length,\r\n                totalContracts: Object.keys(contractGroups).length,\r\n                singleCarContracts: singleCarContractsCount,\r\n                multiCarContracts: resultRows.length,\r\n            };\r\n            */\r\n            // analyzeMultiCarContracts returns `results` (the multi-car ones).\r\n            // It DOES NOT return the summary stats (totalRows, single etc).\r\n            // I need to replicate that summary logic if I want to maintain parity.\r\n\r\n            // Let's re-read analysis.js to see if it returns summary stats.\r\n            // It returns ONLY `results` array.\r\n\r\n            // I should verify if I need to enhance analysis.js or calculate stats here.\r\n            // To maintain \"pure function\" in utils, I should calculate stats here or separate stats function.\r\n            // I'll calculate stats here to match the output expectation of the page.\r\n\r\n            const uniqueContracts = new Set(accumulatedRows.map(r => r['Contract No.'])).size;\r\n            const multiCount = results.length;\r\n\r\n            const summary = {\r\n                totalRows: accumulatedRows.length,\r\n                totalContracts: uniqueContracts,\r\n                singleCarContracts: uniqueContracts - multiCount,\r\n                multiCarContracts: multiCount,\r\n            };\r\n\r\n            self.postMessage({\r\n                success: true,\r\n                results,\r\n                summary\r\n            });\r\n\r\n            // Cleanup\r\n            accumulatedRows = [];\r\n        }\r\n        else if (type === 'RESET') {\r\n            accumulatedRows = [];\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Worker Error details:\", error);\r\n        self.postMessage({ error: error.message });\r\n        accumulatedRows = [];\r\n    }\r\n};\r\n"],"names":["formatDateDDMMYYYY","date","Date","isNaN","day","String","getUTCDate","padStart","month","getUTCMonth","year","getUTCFullYear","concat","analyzeMultiCarContracts","data","contractGroups","debugCounts","forEach","row","contractNo","plateNumberRaw","plateNumber","toString","replace","toUpperCase","customerName","carModel","revenueDate","dateStr","trim","parts","split","length","d","getTime","map","p","parseInt","UTC","parseSheetDate","cars","carsRaw","dates","push","results","Object","values","contract","keys","join","carEntries","carDetails","car","sortedDates","sort","a","b","from","to","carsCount","accumulatedRows","self","onmessage","event","type","Array","isArray","i","postMessage","progress","uniqueContracts","Set","r","size","multiCount","summary","totalRows","totalContracts","singleCarContracts","multiCarContracts","success","error","console","message"],"sourceRoot":""}